---
title: "Assignment2"
author: "Mengyu Li"
date: "June 18, 2016"
output: html_document
---

## Allowed Packages
To finish the assignment, we need to load 2 packages first:
```{r}
library(readr)
library(stringr)
```

## Problems 

### Problem 1 - Names of Files (8 pts)

Imagine that you need to generate the names of 4 data files (with .png extension). All the files have the same prefix name but each of them has a different number: `plot001.png`, `plot002.png`, `plot003.png`, and `plot004.png`. We can generate a character vector with these names in R. One naive solution would be to write something like this:
```{r}
files <- c('plot001.png', 
           'plot002.png', 
           'plot003.png', 
           'plot004.png')
```

Now imagine that you need to generate 100 file names. You could write a vector with 100 file names but it's going to take you a while.

Generate a character vector named `files100` containing 100 files names of the form `plotxxx.png` i.e. the names should look like `plot001.png`, `plot002.png`, `plot003.png`, ..., `plot099.png`, `plot100.png`.

Do not use any looping constructions (we haven't covered this yet, and they're slower in `R` for this task).

```{r}
# Problem 1
numbers100 <- str_pad(c(1:100), width = 3, side = "left", pad = "0")
files100 <- str_c("plot", numbers100, ".png")
files100
```

### Problem 2 - USA States Names (8 pts)

One of the datasets that comes with R is `USArrests`. The row names of this data set correspond to the 50 states. This next problem refers to the `states` vector below.  Ignore upper and lower case.

```{r}
states <- rownames(USArrests)
states <- tolower(states)
```

1. How many states contain the letter `i`?
```{r}
sum(str_detect(states, "i"))
```

2. How many states do not contain the letter `a`?
```{r}
length(states) - sum(str_detect(states, "[a]"))
```

3. Which states contain the letter `j`?
```{r}
str_subset(states, "j")
```

4. Which states are formed by two words?
```{r}
str_subset(states, " ")
```

5. Which states start with `W` and end with a consonant (non-vowel)?
```{r}
str_subset(states, "^[w].*[^AEIOUaeiou]$")
```

6. Which states contain at least three `i`'s (e.g. Illinois)?
```{r}
states[str_count(states, "i") >= 3]
```

7. Which states contain exactly five vowels (e.g. California)?
```{r}
states[str_count(states, "[aeiou]") == 5] 
```

8. Which states contain three consecutive vowels (e.g. Hawaii)?
```{r}
str_subset(states, "[aeiou][aeiou][aeiou]")
```

### Problem 3 Colors in Hexadecimal Notation (4 pts)

Write a function `is_hex()` that checks whether the input is a valid color in hexadecimal notation. A hex color starts with a hash `#` symbol followed by six hexadecimal digits: 0 to 9, and the first six letters A, B, C, D, E, F. Your function should not distinguish between upper and lower case letters.

```{r}
is_hex <- function(inputColor){
  
  inputColor <- tolower(inputColor)
  return(str_detect(inputColor, "^[#][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]$"))
}
```

Change `eval` to `TRUE` to test your function.
```{r, eval=TRUE}
is_hex("#ff0000")  # TRUE
is_hex("#123456")  # TRUE
is_hex("#12Fb56")  # TRUE

is_hex("#1234GF")  # FALSE
is_hex("#1234567") # FALSE
is_hex("blue")     # FALSE
```

### Problem 4 - Reversing Characters (4 pts)

Write a function called `reverse_chars` that reverses a string by characters. You may find the `rev` function useful.

```{r}
reverse_chars <- function(inputCharacter){
  result <- ""
  ReverseCharacter <- rev(str_split(inputCharacter,"")[[1]])
  for (i in 1:str_length(inputCharacter)) {
    result <- str_c(result, ReverseCharacter[i])
  }
  return(result)
}
```

Change `eval` to `TRUE` to test your function.
```{r, eval=TRUE}
reverse_chars("Rictusempra")
reverse_chars("Lumox Maxima")
reverse_chars("Repello Muggletum")
```

### Problem 5 - Cleaning XML Data (4 points)

Rarely does text data come clean enough for immediate use.  In this exercise, you'll get a taste of parsing XML Data, which a non-tabular data format that makes use of tags.  The data are sometimes presented in the following form:
```
<tag_name>data</tag_name>
```
Your job is to write a function `remove_tag` that takes a vector of text from an XML document and removes the tags, returning a character vector with only the data values.  So, for example:

* `<common>dandelion</common>` is converted to `dandelion`
* `<genus>Taraxacum</genus>` is converted to `Taraxacum`
* `<kingdom>Plantae</kingdom>` is converted to `Plantae`

```{r}
remove_tag <- function(InputCharacter){
  extractedCharacter <- str_extract(InputCharacter, ">.*<")
  
  result <- 1:length(InputCharacter)
  for (i in 1:length(InputCharacter)) {
    result[i] = str_split(extractedCharacter, "[><]")[[i]][2]
  }
  return(result)
}
```

Test your code:
```{r, eval = T}
phylo <- c("<common>dandelion</common>",
           "<genus>Taraxacum</genus>",
           "<kingdom>Plantae</kingdom>")
remove_tag(phylo)
```

### Problem 6 - Processing DNA (12 points)

Our genetic blueprint, DNA, consists of nucleotides each composed of a sugar, deoxyribose; a phosphate group; and one of four nitrogen-containing nucleobases: cytosine (C), guanine (G), adenine (A), and thymine (T).  Simplifying the biology a little (ok, a lot), every three bases in a corresponds to an amino acid, a building block for proteins.  For example, the triplets `TTT-CTT-ATT` corresponds to the amino acids _Phenylalanine_, _Leucine_, and _Isoleucine_, which is then abbreviated as `F-L-I`.  

That's the extent of the biology you need to know, but if you want to read more of the technicalities, [see this wikipedia article for more information.](https://en.wikipedia.org/wiki/DNA_codon_table)  We ignore START codons in this problem.

A csv file of the DNA to amino acid conversion is given with the homework.  Use a relative path from your `hw2` directory to load that data frame in with the `read_csv` function in the `readr` package.

Write a function `dna_to_aa` that converts a sequence of DNA given as a string into a sequence of amino acids.  If the sequence contains an invalid DNA character (something outside CGAT), your function should return an error stating "Invalid DNA sequence".

Hints: 

* Break this problem down into steps.  This is more than a one-liner
* `str_replace_all` can take a named vector as one of its arguments.

```{r}
dna_to_aa <- function(InputDNA){
  if((str_length(InputDNA) %% 3) != 0 | str_count(InputDNA, "[^AGCT]") > 0){
    return("Invalid DNA sequence.")
  }
  numberOfAminoAcid <- str_length(InputDNA)/3
  AminoAcid <- rep("",numberOfAminoAcid)
  result <- rep("", numberOfAminoAcid)
  startId <- 1
  endId <- 3
  PositionOfAminoAcid <- 1
  while(endId != (str_length(InputDNA) + 3)){
    AminoAcid[PositionOfAminoAcid] = substr(InputDNA, startId, endId)
    startId <- startId + 3
    endId <- endId + 3
    PositionOfAminoAcid <- PositionOfAminoAcid + 1 
  }
  transfer <- read_csv("codons.csv")
  for(i in 1:numberOfAminoAcid){
    for (j in 1:nrow(transfer)) {
      if(AminoAcid[i] == transfer[[1]][j]){
        result[i] <- transfer[[2]][j]
      }
    }
  }
  
  NameOfAminoAcid <- ""
  for (j in 1 : numberOfAminoAcid) {
    NameOfAminoAcid <- str_c(NameOfAminoAcid , result[j])
  }
  return(NameOfAminoAcid)
}
```

Test your function:
```{r, eval = T}
dna_to_aa("GAGCCATGCATT") # "EPCI"
dna_to_aa("ATCTAGATAGTAGGC") # "IStopIVG"
dna_to_aa("UCUGAGAAU") # "Invalid DNA sequence"
```




